## 整体设计思路

从架构视角看，秒杀系统本质是一个高性能、高一致、高可用的三高系统，设计时需要对这三个方面拆开分析。

### 高性能

#### 动静分离

商品列表页面作为频繁访问页面，事实上它的数据不需要强一致性，我们可以把商品列表页面静态化并放入 redis 中作为高速缓存。

### 一致性

#### 库存一致性

其实核心问题就是如何防止库存超卖，业界比较常见的解决方案是预扣库存超时回收，也可以使用分段的分布式锁（redis zookeeper 都有对应实现），数据库的乐观锁、字段设置为负触发回滚等。

本项目较为简单，固定所有用户只能抢 1 个，redis decr 原子操作保证订单可生效，数据库层面也会在库存为负时触发回滚。

后续改进：当有用户重复下单时，为保持双写一致性需要手动触发 redis 的回滚，实现为一个 try catch 语句，catch 段加回扣掉的库存。

#### 一致性能优化

1. 高并发读，实际上就是构建一个漏斗，使海量请求经过层层过滤只留下小部分尝试实际数据库的访问。
2. 高并发写，实际上落地到数据库就是对单行数据的高并发访问，可以考虑应用层的排队（性能差，较低级），数据库层面的排队（性能高，较高级）。

在本项目中，消费者端：
先检查用户是否登录（线程局部变量是否有值） -> 是否正确回答了图形验证码的问题 -> 该用户对应的 path UUID 是否正确 -> 本地内存检查对应秒杀商品是否结束 -> redis 预减库存 -> 数据库是否已有重复订单 -> 秒杀请求加入消息队列。

生产者端：收到消息后会再检查一次是否重复下单 -> 真正的下单事务操作

### 高可用

#### 流量削峰

通过对秒杀接口单用户限流控制并发请求量，同时通过图形验证码过滤机器人脚本。此外，使用消息队列（异步、解耦、日志、削锋）优化用户体验，在点击秒杀后马上返回一个加载中页面。

